<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java学习记录</title>
      <link href="/2020/04/21/java/"/>
      <url>/2020/04/21/java/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h1><p>类的加载分为隐式加载和显示加载</p><blockquote><p>隐式加载：隐式加载指的是程序在使用new等方式创建对象时，会隐式的调用类的加载器把对应的类加载到JVM中</p><p>显示加载：显示加载指的是通过直接调用class.forName()方法来把所需要的类加载到JVM中</p></blockquote><pre><code>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到JVM中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</code></pre><p>Java的类加载器有三个，对应Java的三种类:系统类、扩展类和自定义类</p><blockquote><p>Bootstrap Loader  // 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C/C++标准库中的类)</p><p>ExtClassLoader   // 负责加载扩展类(就是继承类和实现类)</p><p>AppClassLoader   // 负责加载应用类(程序员自定义的类)<br>类加载的主要步骤分为：</p></blockquote><ol><li>装载。根据查找路径找到相对应的class文件，然后导入</li><li>链接。链接又可以分为3步<br>①检查。检查待加载的class文件的正确性。<br>②准备。给类中的静态变量分配存储空间。<br>③解析。将符号引用转换成直接引用.  </li><li>初始化。对静态变量和静态代码块执行初始化工作   <h1 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h1> 主要作用：回收程序中不在使用的内存<br>垃圾回收期来自动检测对象的作用域，可自动的把不在被使用的存储空fang间释放掉。<br>垃圾回收器负责完成3项任务：分配内存、确保被引用对象的内存不被错误的回收以及回收不再被引用的对象的内存空间。<br>垃圾回收器优点：  提高了开发人员的生产效率,保证了程序的稳定性.<br>垃圾回收器缺点：垃圾回收器必须跟踪内存的使用情况，这必会增加JVM负担，降低程序的执行效率。  <h2 id="判断对象存活算法"><a href="#判断对象存活算法" class="headerlink" title="判断对象存活算法"></a>判断对象存活算法</h2>1、 引用计数器算法：<br>引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了。<br>引用计数器实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是A,B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法已经不再使用了。<br>2、 根搜索方法：<br>根搜索方法是通过一些“GCRoots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被GCRoots的引用链连接的时候，说明这个对象是不可用的。<br>GCRoots对象包括：<br>虚拟机栈（栈帧中的本地变量表）中的引用的对象。<br>方法区域中的类静态属性引用的对象。<br>方法区域中常量引用的对象。<br>本地方法栈中JNI（Native方法）的引用的对象。  <h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2></li></ol><p>1、标记-清除算法<br>标记-清除（Mark-Sweep）算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在清除阶段，清除所有未被标记的对象。  </p><p>2、 标记整理算法<br>标记整理算法类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。<br>  缺点：<br>        1、效率问题，（同标记清除算法）标记和整理两个过程的效率都不高；<br>  优点：<br>        1、相对标记清除算法，解决了内存碎片问题。<br>        2、没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。</p><p>3、 复制算法<br>复制算法可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。 </p><p>4、 分代收集算法<br>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法，在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。</p><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><pre><code>内存泄漏是指一个不再被程序使用的对象或变量还在内存中占有存储空间  </code></pre><p>内存泄漏的两种情况：一种是在堆中申请的空间没有被释放；二是对象已不在被使用，但还任然在内存中保留着。而垃圾回收机制的引入可以有效的解决第一种情况；对第二种情况而言垃圾回收机制则无法保证不再使用的对象会被释放。（java语言主要指的是第二种情况）<br>引起内存泄漏主要有以下几个方面：<br>1）静态集合类，例如HashMap和Vector。如果这些容器为静态的，由于它们的生命周期与程序一致，那么容器中的对象在程序结束之前将不能被释放从而造成内存泄漏。<br>2）各种连接，例如数据库连接、网络连接以及IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显示的关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。<br>3）监听器。在java语言中，往往会使用到监听器。通常一个应用中会用到多个监听器，但在释放对象的同时往往没有相应的删除监听器，这也可能导致内存泄漏。<br>4）变量不合理的作用域。一般而言，如果一个变量定义的作用范围大于其使用范围，很有可能会造成内存泄漏，另一方面如果没有及时的吧对象设置为null，很有可能会导致内存泄漏的发生。<br>5）单例模式可能会造成内存泄漏。</p><pre><code>Class BigClass{}  Class Singleton{    private BigClass bc;    private static Singleton instance Singleton(new BigClass);    private Simgleton(BigClass bc){this.bc=bc}    public Singleton getInstance(){      return instance;    }  }     </code></pre><p>  Singleton存在一个对对象BigClass的引用，单例对象以静态变量的方式存储，因此在JVM的整个生命周期都存在，同时有一个对象BigClass的引用，导致BigClass不能被回收。  </p><p>以发生的方式来分类，内存泄漏可以分为4类:</p><ol><li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</li><li>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </li><li>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </li><li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 </li></ol><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>Public：当前项目任何包中都可使用<br>Private：只能在当前类中使用<br>Protected：在当前包的所有类中使用以及不同包的子类中使用<br>默认修饰符default：在当前包的所有类中使用  </p><h1 id="Java程序初始化顺序"><a href="#Java程序初始化顺序" class="headerlink" title="Java程序初始化顺序"></a>Java程序初始化顺序</h1><p>父类静态变量 ——&gt; 父类静态代码块 ——&gt; 子类静态变量 ——&gt; 子类静态代码块 ——&gt; 父类非静态变量 ——&gt; 父类非静态代码块 ——&gt; 父类构造函数 ——&gt; 子类非静态变量 ——&gt; 子类非静态代码块 ——&gt; 子类构造函数</p><h1 id="Java中数据传递的方式"><a href="#Java中数据传递的方式" class="headerlink" title="Java中数据传递的方式"></a>Java中数据传递的方式</h1><p>基本传值  ： 不改变原数据的值<br>引用传值  ： 改变原数据的值<br>基本数据类型传递是该数据的本身对它的修改，不会被保留。<br>引用数据类型传递也是这个变量值的本身，即对象的引用，而非对象本身，其值的修改将会被保留  </p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="右移（-gt-gt-）"><a href="#右移（-gt-gt-）" class="headerlink" title="右移（>>）"></a>右移（&gt;&gt;）</h3><p>正数右移高位补0<br>无符号右移无论正负用0进行补位<br>负数右移高位补1  </p><h3 id="左移（-lt-lt-）"><a href="#左移（-lt-lt-）" class="headerlink" title="左移（<<）"></a>左移（&lt;&lt;）</h3><p>表示左移 左移n位表示原来的值乘2的n次方<br>正数或者负数左移，低位都是用0补<br>若超出该类型最大位数，那么编译器会对位移的位数取模   int型32位 取模 33%32 实际移动一位</p><h3 id="位与-amp"><a href="#位与-amp" class="headerlink" title="位与(&amp;)"></a>位与(&amp;)</h3><p>第一个操作数的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0 （结果只有1和0）</p><h3 id="位或"><a href="#位或" class="headerlink" title="位或( | )"></a>位或( | )</h3><p>第一个操作数的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0</p><h3 id="位异或"><a href="#位异或" class="headerlink" title="位异或( ^ )"></a>位异或( ^ )</h3><p>第一个操作数的的第n位于第二个操作数的第n位相反，那么结果的第n为也为1，否则为0</p><h3 id="位非"><a href="#位非" class="headerlink" title="位非( ~ )"></a>位非( ~ )</h3><p>操作数的第n位为1，那么结果的第n位为0，反之。</p><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>Round方法:表示四舍五入<br>Ceil方法：表示向上取整<br>Floor方法：表示向下取整  </p><h1 id="String、StringBuffer、StringBuilder、StringTockenizer"><a href="#String、StringBuffer、StringBuilder、StringTockenizer" class="headerlink" title="String、StringBuffer、StringBuilder、StringTockenizer"></a>String、StringBuffer、StringBuilder、StringTockenizer</h1><p>String<br>是不可变类，可以用构造函数初始化和赋值初始化  </p><p>StringBuffer<br>是可变类，当对象被创建后任然可以对其值进行修改，只能构造函数初始化<br>append（基本数据类型 x） 添加字符串<br>public stringBuffer reverse（） 对字符串进行反转<br>stringBuffer delete（int left，int right） 左闭右开的删除<br>public char charAt（int n） 取指定位置的字符<br>public void setCharAt（int n，char c）将指定位置的n改成c<br>stringBuffer replace（int n，int m，String str）从n-m改成str<br>public String substring（int start，int and）<br>public int indexOf（string str）返回str在字符串首次查询的位置<br>public int length（）  </p><p>StringBuilder<br>与stringBuffer 类似，都是字符串缓冲区，但线程是不安全的，效率较StringBuffer高  </p><p>stringTockenizer<br>用来分割字符串的工具类  </p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a>方法重载（overload）</h3><p>方法名相同，而参数不同，返回类型也可以不同，但每个重载的方法都必须有一个独一无二的参数类型列表  </p><h3 id="方法覆盖（override）"><a href="#方法覆盖（override）" class="headerlink" title="方法覆盖（override）"></a>方法覆盖（override）</h3><p>在子类中重写父类的方法，方法名称相同，参数必须相同，返回值类型相同或其子类类型，修饰符不能小于父类范围  </p><h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><p>一般作用在：成员变量，成员方法（static方法中不能使用this和super关键字，以及实现单例模式），代码块(用来初始化静态变量)，内部类（只有内部类才能被定义为ststic）<br>作用 : 为某特定数据类型或对象分配单一的存储空间，实现某个方法或属性与类而不是对象关联</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>修饰类：表示类为最终的类，也就是不能被继承<br>修饰方法：表示方法为最终的，改方法不能被重写<br>修饰属性：表示该属性为常量，需在声明式完成赋值，且其后值不允许被修改  </p><h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><h2 id="可变类与不可变类的区别"><a href="#可变类与不可变类的区别" class="headerlink" title="可变类与不可变类的区别"></a>可变类与不可变类的区别</h2><p>不可变类是指当创建了这个类的实例后，就不允许修改它的属性值。在JDK的基本类库中，所有基本类型的包装类，如String、Integer和Long类，都是不可变类，<br>不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。</p><h2 id="如何创建一个不可变类？"><a href="#如何创建一个不可变类？" class="headerlink" title="如何创建一个不可变类？"></a>如何创建一个不可变类？</h2><ol><li>所有成员都是private</li><li>不提供对成员的改变方法，例如：setXXXX</li><li>确保所有的方法不会被重载。手段有两种：使用final Class(强不可变类)，或者将所有类方法加上final(弱不可变类)。</li><li>如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。</li><li>可使用覆盖object类的equals()方法和hashcode()方法。在equals方法中，根据对象的属性值来比较两个对象是否相等，并且保证用equals()方法判断为相等的两个对象的hashcode()方法的返回值也相等，这可以保证这些对象能被正确地放到hashmap或hashset集合中。</li></ol><h1 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h1><p>1）强引用<br>　　指创建一个对象并把这个对象赋给一个引用变量。强引用有引用变量指向时永远不会被垃圾回收。即使内存不足的时候。像上述Map的小例子中，cloneMapShallow方法的实现就是强引用。要注意的是，在做强引用的时候，用完最好记得解除这种引用关系(置为null)。<br>2）软引用　　<br>软引用通过SoftReference类来实现。软引用的对象当系统内存充足时和强引用没有太多区别，但内存不足时会回收软引用的对象。</p><pre><code>public static void softReference() {        //创建软引用数组        SoftReference&lt;TestReference&gt;[] p = new SoftReference[100];        //赋值        for (int i = 0; i &lt; p.length; i++) {            p[i] = new SoftReference&lt;TestReference&gt;(new TestReference("name:" + i));        }        //测试        System.out.println(p[1].get().name);        System.out.println(p[4].get().name);        //通知系统进行回收        System.gc();        System.runFinalization();        System.out.println("---------------");        System.out.println(p[1].get().name);        System.out.println(p[4].get().name);    }  </code></pre><p>3）弱引用<br>弱引用通过weakReference类来实现。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p><pre><code>public static void weakReference() {        String str = new String("Test Java");        // 创建一个如引用对象 指向 str对象        WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(str);        str = null;        // 输出        System.out.println(wr.get());        // 强制垃圾回收        System.gc();        System.out.println(wr.get());    }</code></pre><p>4）虚引用<br>　　软引用和弱引用可以单独使用，虚引用不能单独使用，需引用的作用是就跟踪对象被垃圾回收的状态，程序可以通过检测与虚引用关联的虚引用队列是否已经包含了指定的虚引用，从而了解虚引用的对象是否即将被回收。<br>　　虚引用通过PhantomRefence类实现，它本身对对象没有影响，类似与没有应用，对象甚至感觉不到虚引用的存在，如果一个对象只有一个虚引用存在，那么他就类似没有应用存在。</p><pre><code>public static void phantomReference() {        // 创建一个对象        String str = new String("Test Java");        // 创建一个引用队列        ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();        // 创建一个虚引用，指定引用对象.不能单独使用必须关联引用队列        PhantomReference pr = new PhantomReference(str, rq);        // 切断强引用        str = null;        // 试图取得虚引用对象        System.out.println(pr.get());        // 垃圾回收        System.gc();        System.runFinalization();        // 取出引队列中的最先进入队列的引用与pr进行比较        System.out.println(rq.poll() == pr);    }</code></pre><h1 id="Java内部类"><a href="#Java内部类" class="headerlink" title="Java内部类"></a>Java内部类</h1><p>分四种：成员内部类、局部内部类、静态内部类和匿名内部类。</p><ol><li><p>成员内部类： 即作为外部类的一个成员存在，与外部类的属性、方法并列。<br>注意：成员内部类中不能定义静态变量,但可以访问外部类的所有成员。<br>a. 内部类中不允许定义静态变量<br>b. 内部类中外部类的实例变量可以共存<br>c. 外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量<br>d. 在内部类中访问内部类自己的变量直接用变量名<br>e. 也可以在内部类中用”this.变量名”来访问内部类变量<br>f. 访问外部类中与内部类同名的实例变量可用”外部类名.this.变量名”。<br>g. 外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量<br>h. 外部类的静态方法访问成员内部类，与在外部类外部访问成员内部类一样.<br>成员内部类的优点：<br>⑴ 内部类作为外部类的成员，可以访问外部类的私有成员或属性。（即使将外部类声明为PRIVATE，但是对于处于其内部的内部类还是可见的。<br>⑵ 用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。<br>注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。  </p></li><li><p>局部内部类： 即在方法中定义的内部类，与局部变量类似，在局部内部类前不加修饰符public或private，其范围为定义它的代码块。<br>注意：局部内部类中不可定义静态变量，可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的。<br>a. 可以定义与外部类同名的变量如果内部类没有与外部类同名的变量，在内部类中可以直接访问外部类的实例变量<br>b. 可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的<br>c. 如果内部类中有与外部类同名的变量，直接用变量名访问的是内部类的变量<br>d. 用”this.变量名” 访问的也是内部类变量<br>e. 用外部”外部类类名.this.变量名” 访问的是外部类变量<br>f. 访问局部内部类必须先有外部类对象<br>注意：在类外不可直接生成局部内部类（保证局部内部类对外是不可见的）。要想使用局部内部类时需要生成对象，对象调用方法，在方法中才能调用其局部内部类。通过内部类和接口达到一个强制的弱耦合，用局部内部类来实现接口，并在方法中返回接口类型，使局部内部类不可见，屏蔽实现类的可见性。</p></li><li><p>静态内部类： 静态内部类定义在类中，任何方法外，用static定义。<br>注意：静态内部类中可以定义静态或者非静态的成员<br>静态内部类可以用public,protected,private修饰<br>静态内部类中可以定义静态或者非静态的成员<br>静态内部类只能访问外部类的静态成员<br>静态内部类不能访问外部类的非静态成员<br>包括非静态变量和非静态方法<br>外部类访问内部类的静态成员：内部类.静态成员<br>外部类访问内部类的非静态成员:实例化内部类即可<br>注意：生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成,而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。<br>注意：当类与接口（或者是接口与接口）发生方法命名冲突的时候，此时必须使用内部类来实现。用接口不能完全地实现多继承，用接口配合内部类才能实现真正的多继承。</p></li><li><p>匿名内部类：匿名内部类是一种特殊的局部内部类，它是通过匿名类实现接口。<br>匿名内部类的特点：<br>1、一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。<br>2、只是为了获得一个对象实例，不需要知道其实际类型。<br>3、类名没有意义，也就是不需要使用到。<br>静态内部类可以用public,protected,private修饰<br>静态内部类中可以定义静态或者非静态的成员<br>静态内部类只能访问外部类的静态成员，包括静态变量和静态方法<br>静态内部类不能访问外部类的非静态成员，包括非静态变量和非静态方法<br>外部类访问内部类的静态成员：内部类.静态成员<br>外部类访问内部类的非静态成员:实例化内部类即可<br>注：一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类，没有类名，根据多态，我们使用其父类名。因他是局部内部类，那么局部内部类的所有限制都对其生效。匿名内部类是唯一一种无构造方法类。大部分匿名内部类是用于接口回调用的。匿名内部类在编译的时候由系统自动起名Out$1.class。如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。因匿名内部类无构造方法，所以其使用范围非常的有限。当需要多个对象时使用局部内部类，因此局部内部类的应用相对比较多。匿名内部类中不能定义构造方法。如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。</p></li></ol><p>内部类总结：<br>1.首先，把内部类作为外部类的一个特殊的成员来看待，因此它有类成员的封闭等级：private ,protected,默认(friendly),public<br>它有类成员的修饰符: static,final,abstract<br>2.非静态内部类nested inner class,内部类隐含有一个外部类的指针this,因此，它可以访问外部类的一切资源（当然包括private）<br>外部类访问内部类的成员，先要取得内部类的对象,并且取决于内部类成员的封装等级。<br>非静态内部类不能包含任何static成员.<br>3.静态内部类：static inner class,不再包含外部类的this指针，并且在外部类装载时初始化.<br>静态内部类能包含static或非static成员.<br>静态内部类只能访问外部类static成员.<br>外部类访问静态内部类的成员，循一般类法规。对于static成员，用类名.成员即可访问，对于非static成员，只能用对象.成员进行访问<br>4.对于方法中的内部类或块中内部类只能访问块中或方法中的final变量。  </p><p>类成员有两种static , non-static，同样内部类也有这两种<br>non-static 内部类的实例，必须在外部类的方法中创建或通过外部类的实例来创建(OuterClassInstanceName.new innerClassName(ConstructorParameter)),并且可直接访问外部类的信息,外部类对象可通过OuterClassName.this来引用<br>static 内部类的实例, 直接创建即可，没有对外部类实例的引用。<br>内部类不管static还是non-static都有对外部类的引用<br>non-static 内部类不允许有static成员</p><p>方法中的内部类只允许访问方法中的final局部变量和方法的final参数列表，所以说方法中的内部类和内部类没什麽区别。但方法中的内部类不能在方法以外访问，方法中不可以有static内部类<br>匿名内部类如果继承自接口,必须实现指定接口的方法,且无参数<br>匿名内部类如果继承自类,参数必须按父类的构造函数的参数传递</p><h1 id="Instanceof（对象判断）"><a href="#Instanceof（对象判断）" class="headerlink" title="Instanceof（对象判断）"></a>Instanceof（对象判断）</h1><p>instanceof的用处：判断左边对象是否为右边类的实例；<br>只能用作对象的判断。<br>返回值类型为：boolean<br>使用：boolean result=female instaceof Person; //female为对象；Person为类</p><h1 id="Assert（断言）"><a href="#Assert（断言）" class="headerlink" title="Assert（断言）"></a>Assert（断言）</h1><p>断言是一个软件调试的方法，提供 一种在代码中进行正确性检查的机制，通常在主程序开发个测试时使用。(为了提高程序的效率，软件发布后，assert检查默认是关闭的)<br>主要作用：检查控制流<br>检查输入参数是否有效<br>检查程序不变量  </p><h1 id="Volatile-类型修饰符"><a href="#Volatile-类型修饰符" class="headerlink" title="Volatile(类型修饰符)"></a>Volatile(类型修饰符)</h1><p>被设计用来修饰被不同线程访问和修改的变量，被volatile类型定义的变量相当于系统直接从内存中提取，而不会利用缓存<br>示例：private volati Boolean flag<br>缺点： 不能保证操作的原子性，并且使用volatile会阻止编译器对代码的优化。  </p><h1 id="Strictfp（关键字-strict-float-point的缩写）"><a href="#Strictfp（关键字-strict-float-point的缩写）" class="headerlink" title="Strictfp（关键字 strict float point的缩写）"></a>Strictfp（关键字 strict float point的缩写）</h1><p>指的是精确浮点，用来确保浮点数运算的准确性<br>当一个类被strictfp修饰时，所有方法都会自动被syrictfp修饰。<br>示例：public strictfp class Test{}  </p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Finally中代码执行时间：由于程序执行return意味着结束，因此任何语句要执行都只能在return前执行（除非碰到exit 函数）<br>Finally代码块不一定执行：<br>1&gt;进入try语句块之前出现异常，会直接结束<br>2&gt;档程序在try块中强制退出时也不会执行finally块<br>异常处理原理：<br>异常是指程序运行时（非编译时）所发生的非正常情况或错误，当程序违反了语义规则时，JVM就会将出现的错误表示为一个异常并抛出<br>目的 :为了提高程序的安全性和鲁棒性</p><h1 id="UNICODE编码"><a href="#UNICODE编码" class="headerlink" title="UNICODE编码"></a>UNICODE编码</h1><p>　　Java开发者必须牢记：在Java中字符仅以一种形式存在，那就是Unicode（不选择任何特定的编码，直接使用他们在字符集中的编号，这是统一的唯一方法）。由于java采用unicode编码，char 在java中占2个字节。2个字节（16位）来表示一个字符。<br>　　这里的Java中是指在JVM中、在内存中、在代码里声明的每一个char、String类型的变量中。<br>　　JVM的折中约定使得一个字符分为两部分：JVM内部和OS的文件系统。在JVM内部，统一使用Unicode表示，当这个字符被从JVM内部移到外部（即保存为文件系统中的一个文件的内容时），就进行了编码转换，使用了具体的编码方案。因此可以说所有的编码转换只发生在边界的地方，JVM和OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。</p><h1 id="Cloneable接口（标记接口）"><a href="#Cloneable接口（标记接口）" class="headerlink" title="Cloneable接口（标记接口）"></a>Cloneable接口（标记接口）</h1><blockquote><p>要想一个类可以被clone，必须满足两点，<br>第一，它必须实现了Cloneable接口，否则会抛出CloneNotSupportedException异常；<br>第二，它必须提供一个public的clone方法，也就是重写Object.clone()方法，否则编译不能通过。<br>第三，对于存在可变域的类，在clone方法中需要对这些可变域进行拷贝（即深拷贝）。               </p></blockquote><p>实现cloneable接口的类标记为可克隆的而且它的对象可以使用在object类中定义的clone()方法克隆,当类只有一些基本的数据类型时就采用<br>但当类中包含了一些对象时，就需要用到深复制<br>深复制两种方案：<br>1、序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写<br>2、继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()</p><h1 id="组合和继承区别"><a href="#组合和继承区别" class="headerlink" title="组合和继承区别"></a>组合和继承区别</h1><table><thead><tr><th align="center">: 组 合 关 系 :</th><th align="center">: 继 承 关 系 :</th></tr></thead><tbody><tr><td align="center">: 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 :</td><td align="center">: 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性:</td></tr><tr><td align="center">: 优点：具有较好的可扩展性    :</td><td align="center">: 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价:</td></tr><tr><td align="center">: 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象    :</td><td align="center">: 缺点：不支持动态继承。在运行时，子类无法选择不同的父类:</td></tr><tr><td align="center">: 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口    :</td><td align="center">: 缺点：子类不能改变父类的接口:</td></tr><tr><td align="center">: 缺点：整体类不能自动获得和局部类同样的接口    :</td><td align="center">: 优点：子类能自动继承父类的接口:</td></tr><tr><td align="center">: 缺点：创建整体类的对象时，需要创建所有局部类的对象    :</td><td align="center">: 优点：创建子类的对象时，无须创建父类的对象:</td></tr></tbody></table><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>意义java中父类实例化无实际意义，因此父类无需实例化<br>1、抽象类不能被实例化<br>2、抽象类中包含属性、方法、构造方法、抽象方法<br>3、抽象方法必须没有方法体<br>4、子类必须重写父类抽象方法<br>5、如果一个类中包含抽象方法，则改类必须是抽象类  </p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>（interface）是与类并行的概念<br>接口可以看做是一个特殊的抽象类，常量与抽象方法集合<br>成员的作用域修饰符都是public<br>常量:所有的常量用public static final 修饰<br>Public static final int i=10;<br>Public static final boolean flag=flag=false;   //绿色代码部分可省略</p><p>抽象方法：所有抽象方法用public abstract修饰<br>Public abstract void method();    //注意：抽象方法没有方法体<br>接口没有构造器<br>类可以实现多个接口<br>实现接口需重写接口的所有方法<br>案例<br>Interface AA{}<br>class bb implements AA{重写接口的所有方法}<br>abstract class cc implement AA{}</p><p>实现接口匿名类对象<br>A b=new A(){重写接口的所有方法};</p><p>总结：<br>1、接口不能被实例化，即不包含构造方法<br>2、接口中可以包含抽象方法，接口中的抽象方法默认为public abstarct<br>3、接口中可包含公有的静态的常量值，默认为public static final<br>4、接口中在jdk8.0以后存在默认方法和静态方法<br>默认方法：<br>Public default void print（）｛｝<br>静态方法<br>Public static void show（）｛｝</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql启动失败</title>
      <link href="/2020/04/08/mysql/"/>
      <url>/2020/04/08/mysql/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/shinny195/article/details/82319218" target="_blank" rel="noopener">mysql启动失败：mysql服务无法启动</a></p><p><a href="https://blog.csdn.net/liu_dong_mei_mei/article/details/104010567" target="_blank" rel="noopener">mysql5.7安装</a></p><p><a href="https://blog.csdn.net/shinny195/article/details/82319218" target="_blank" rel="noopener">mysql发生系统错误2</a><br><img src="https://static-1301638910.cos.ap-guangzhou.myqcloud.com/clipboard_20200408064655.png" alt="clipboard_20200408064655.jpg"></p><p>解决方法：切换到bin目录后，首先删除前面安装的MySQL服务，然后在重新安装MySQL服务，然后启动。<br><img src="https://static-1301638910.cos.ap-guangzhou.myqcloud.com/clipboard_20200408064656.png" alt="clipboard_20200408064656.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springdata学习记录</title>
      <link href="/2020/03/23/springdatasum/"/>
      <url>/2020/03/23/springdatasum/</url>
      
        <content type="html"><![CDATA[<h1 id="springdata简介"><a href="#springdata简介" class="headerlink" title="springdata简介"></a>springdata简介</h1><pre><code>是Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。</code></pre><a id="more"></a><h1 id="相关概述"><a href="#相关概述" class="headerlink" title="相关概述"></a>相关概述</h1><h2 id="ORM概述"><a href="#ORM概述" class="headerlink" title="ORM概述"></a>ORM概述</h2><p>  ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射<br>  简单的说：实现一个应用程序时（不使用O/R Mapping），可能会写特别多数据访问层的代码，从数据库保存数据、修改数据、删除数据，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。</p><h2 id="hibernate概述"><a href="#hibernate概述" class="headerlink" title="hibernate概述"></a>hibernate概述</h2><p>   Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p><h2 id="JPA概述"><a href="#JPA概述" class="headerlink" title="JPA概述"></a>JPA概述</h2><p>  JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。<br>  JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。<br>  JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。JPA怎么取代Hibernate呢？JDBC规范可以驱动底层数据库吗？答案是否定的，也就是说，如果使用JPA规范进行数据库操作，底层需要hibernate作为其实现类完成数据持久化工作。</p><h2 id="JPA案例"><a href="#JPA案例" class="headerlink" title="JPA案例"></a>JPA案例</h2><p>1、Maven工程pom.xml中导入坐标</p><pre><code>&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- hibernate对jpa的支持包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;            &lt;version&gt;${project.hibernate.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- c3p0 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt;            &lt;version&gt;${project.hibernate.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log日志 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- jdbc驱动jar包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>2、配置JPA的核心配置文件<br>** 在java工程的src路径下创建一个名为META-INF的文件夹，在此文件夹下创建一个名为persistence.xml的配置文件 **</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence      http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"    version="2.0"&gt;    &lt;!--配置持久化单元         name：持久化单元名称         transaction-type：事务类型                          RESOURCE_LOCAL：本地事务管理                           JTA：分布式事务管理 --&gt;    &lt;persistence-unit name="myJpa" transaction-type="RESOURCE_LOCAL"&gt;        &lt;!--配置JPA规范的服务提供商 --&gt;        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;        &lt;properties&gt;            &lt;!-- 数据库驱动 --&gt;            &lt;property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" /&gt;            &lt;!-- 数据库地址 --&gt;            &lt;property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/jpa" /&gt;            &lt;!-- 数据库用户名 --&gt;            &lt;property name="javax.persistence.jdbc.user" value="root" /&gt;            &lt;!-- 数据库密码 --&gt;            &lt;property name="javax.persistence.jdbc.password" value="rootroot" /&gt;            &lt;!--jpa提供者的可选配置：我们的JPA规范的提供者为hibernate，所以jpa的核心配置中兼容hibernate的配 --&gt;            &lt;property name="hibernate.show_sql" value="true" /&gt;            &lt;property name="hibernate.format_sql" value="true" /&gt;            &lt;property name="hibernate.hbm2ddl.auto" value="create" /&gt;        &lt;/properties&gt;    &lt;/persistence-unit&gt;&lt;/persistence&gt;</code></pre><p>3、创建数据库表</p><pre><code>CREATE TABLE per_student (      per_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '学生编号(主键)',      per_name varchar(32) NOT NULL COMMENT '学生姓名',      per_age int DEFAULT NULL COMMENT '学生年龄',      per_sex varchar(2) DEFAULT NULL COMMENT '学生性别',      per_major varchar(32) DEFAULT NULL COMMENT '学生专业',      per_phone varchar(64) DEFAULT NULL COMMENT '学生联系电话',      PRIMARY KEY (`per_id`)    ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>4、创建实体类</p><pre><code>import java.io.Serializable;import javax.persistence.*/***        * 所有的注解都是使用JPA的规范提供的注解， *        * 所以在导入注解包的时候，一定要导入javax.persistence下的 */@Entity //声明实体类@Table(name="per_student") //建立实体类和表的映射关系public class Student implements Serializable{    @Id//声明当前私有属性为主键    @GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略    @Column(name="per_id") //指定和表中per_id字段的映射关系    private Long perId;    @Column(name="per_name") //指定和表中per_name字段的映射关系    private String perName;    @Column(name="per_age")//指定和表中per_age字段的映射关系    private String perAge;    @Column(name="per_sex")//指定和表中per_sex字段的映射关系    private String perSex;    @Column(name="per_major")//指定和表中per_major字段的映射关系    private String perMajor;    @Column(name="per_phone")//指定和表中per_phone字段的映射关系    private String perPhone;    public Long getPerId() {        return perId;    }    public void setPerId(Long perId) {        this.perId = perId;    }    public String getPerName() {        return perName;    }    public void setPerName(String perName) {        this.perName = perName;    }    public int getPerAge() {        return perAge;    }    public void setPerAge(int perAge) {        this.perAge = perAge;    }    public String getPerSex() {        return perSex;    }    public void setPerSex(String perSex) {        this.perSex = perSex;    }    public String getPerMajor() {        return perMajor;    }    public void setPerMajor(String perMajor) {        this.perMajor = perMajor;    }    public String getPerPhone() {        return perPhone;    }    public void setPerPhone(String perPhone) {        this.perPhone = perPhone;    }｝</code></pre><p>补充</p><blockquote><p>@Entity<br>    作用：指定当前类是实体类。<br>@Table<br>    作用：指定实体类和表之间的对应关系。<br>    属性：<br>        name：指定数据库表的名称<br>@Id<br>    作用：指定当前字段是主键。<br>@GeneratedValue<br>    作用：指定主键的生成方式。。<br>    属性：<br>        strategy ：指定主键生成策略。<br>@Column<br>    作用：指定实体类属性和数据库表之间的对应关系<br>    属性：<br>        name：指定数据库表的列名称。<br>        unique：是否唯一<br>        nullable：是否可以为空<br>        inserttable：是否可以插入<br>        updateable：是否可以更新<br>        columnDefinition: 定义建表时创建此列的DDL<br>      secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境</p></blockquote><p>5、测试-添加数据</p><pre><code>@Test    public void test() {        /**         * 创建实体管理类工厂，借助Persistence的静态方法获取         *         其中传递的参数为持久化单元名称，需要jpa配置文件中指定         */        EntityManagerFactory factory = Persistence.createEntityManagerFactory("myJpa");        //创建实体管理类        EntityManager em = factory.createEntityManager();        //获取事务对象        EntityTransaction tx = em.getTransaction();        //开启事务        tx.begin();        Student c = new Student();            c.setPerName("张三");            c.setPerAge(18);            c.setPerSex("男");            c.setPerMajor("java开发攻城狮");            c.setPerPhone("17856520896");        //保存操作        em.persist(c);        //提交事务        tx.commit();        //释放资源        em.close();        factory.close();    }</code></pre><h2 id="JPA的API介绍"><a href="#JPA的API介绍" class="headerlink" title="JPA的API介绍"></a>JPA的API介绍</h2><p><strong>Persistence对象</strong><br>Persistence对象主要作用是用于获取EntityManagerFactory对象的 。通过调用该类的createEntityManagerFactory静态方法，根据配置文件中持久化单元名称创建EntityManagerFactory。</p><pre><code>@TestString unitName = "myJpa";EntityManagerFactory factory= Persistence.createEntityManagerFactory(unitName);</code></pre><p><strong>EntityManagerFactory</strong><br>EntityManagerFactory 接口主要用来创建 EntityManager 实例<br>//创建实体管理类<br><code>EntityManager em = factory.createEntityManager();</code><br>由于EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个EntityManagerFactory 对象不会有线程安全问题），并且EntityManagerFactory 的创建极其浪费资源，所以在使用JPA编程时，我们可以对EntityManagerFactory 的创建进行优化，只需要做到一个工程只存在一个EntityManagerFactory 即可</p><p><strong>EntityManager</strong><br>在 JPA 规范中, EntityManager是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。<br>我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作<br>方法说明：</p><blockquote><p>getTransaction : 获取事务对象<br>persist ： 保存操作<br>merge ： 更新操作<br>remove ： 删除操作<br>find/getReference ： 根据id查询</p></blockquote><p><strong>EntityTransaction</strong><br>在 JPA 规范中, EntityTransaction是完成事务操作的核心对象，对于EntityTransaction在我们的java代码中承接的功能比较简单</p><blockquote><p>begin：开启事务<br>commit：提交事务<br>rollback：回滚事务</p></blockquote><h2 id="JPAUtil工具类"><a href="#JPAUtil工具类" class="headerlink" title="JPAUtil工具类"></a>JPAUtil工具类</h2><pre><code>import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.Persistence;public final class JPAUtil {    // JPA的实体管理器工厂：相当于Hibernate的SessionFactory    private static EntityManagerFactory em;    // 使用静态代码块赋值    static {        // 注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致        em = Persistence.createEntityManagerFactory("myPersistUnit");    }    /**     * 使用管理器工厂生产一个管理器对象     *      * @return     */    public static EntityManager getEntityManager() {        return em.createEntityManager();    }}</code></pre><h2 id="JPA增删改查"><a href="#JPA增删改查" class="headerlink" title="JPA增删改查"></a>JPA增删改查</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><pre><code>@Testpublic void Add() {    // 定义对象    Student c = new Student();    c.setPerName("张三");    c.setPerAge(18);    c.setPerSex("男");    c.setPerMajor("java开发攻城狮");    c.setPerPhone("17856520896");    EntityManager em = null;    EntityTransaction tx = null;    try {        // 获取实体管理对象        em = JPAUtil.getEntityManager();        // 获取事务对象        tx = em.getTransaction();        // 开启事务        tx.begin();        // 执行操作        em.persist(c);        // 提交事务        tx.commit();    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre><code>@Testpublic void Merge(){      //定义对象    EntityManager em=null;      EntityTransaction tx=null;      try{          //获取实体管理对象        em=JPAUtil.getEntityManager();        //获取事务对象        tx=em.getTransaction();        //开启事务        tx.begin();        //执行操作        Student c1 = em.find(Student.class, 1L);        c1.setPerName("李四");        em.clear();//把c1对象从缓存中清除出去        em.merge(c1);        //提交事务        tx.commit();     }catch(Exception e){        //回滚事务        tx.rollback();        e.printStackTrace();      }finally{          //释放资源        em.close();      }    }</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>@Testpublic void testRemove() {    // 定义对象    EntityManager em = null;    EntityTransaction tx = null;    try {        // 获取实体管理对象        em = JPAUtil.getEntityManager();        // 获取事务对象        tx = em.getTransaction();        // 开启事务        tx.begin();        // 执行操作        Student c1 = em.find(Student.class,1L);        em.remove(c1);        // 提交事务        tx.commit();    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="根据id查询"><a href="#根据id查询" class="headerlink" title="根据id查询"></a>根据id查询</h3><p>立即加载的策略方法</p><pre><code>@Testpublic void testGetOne() {    // 定义对象    EntityManager em = null;    EntityTransaction tx = null;    try {        // 获取实体管理对象        em = JPAUtil.getEntityManager();        // 获取事务对象        tx = em.getTransaction();        // 开启事务        tx.begin();        // 执行操作        Customer c1 = em.find(Customer.class, 1L);        // 提交事务        tx.commit();        System.out.println(c1); // 输出查询对象    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><p> 延迟加载的策略方法：</p><pre><code>/** * 查询一个： 使用延迟加载策略 */@Testpublic void testLoadOne() {    // 定义对象    EntityManager em = null;    EntityTransaction tx = null;    try {        // 获取实体管理对象        em = JPAUtil.getEntityManager();        // 获取事务对象        tx = em.getTransaction();        // 开启事务        tx.begin();        // 执行操作        Customer c1 = em.getReference(Customer.class, 1L);        // 提交事务        tx.commit();        System.out.println(c1);    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h3 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h3><pre><code>//查询所有@Test    public void findAll() {        EntityManager em = null;        EntityTransaction tx = null;        try {            //获取实体管理对象            em = JPAUtil.getEntityManager();            //获取事务对象            tx = em.getTransaction();            tx.begin();            // 创建query对象            String jpql = "from Student";            Query query = em.createQuery(jpql);            // 查询并得到返回结果            List list = query.getResultList(); // 得到集合返回类型            for (Object object : list) { //遍历结果集                System.out.println(object);            }            tx.commit();        } catch (Exception e) {            // 回滚事务            tx.rollback();            e.printStackTrace();        } finally {            // 释放资源            em.close();        }    }</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><pre><code>//分页查询@Testpublic void findPaged () {    EntityManager em = null;    EntityTransaction tx = null;    try {        //获取实体管理对象        em = JPAUtil.getEntityManager();        //获取事务对象        tx = em.getTransaction();        tx.begin();        //创建query对象        String jpql = "from Student";        Query query = em.createQuery(jpql);        //起始索引        query.setFirstResult(0);        //每页显示条数        query.setMaxResults(2);        //查询并得到返回结果        List list = query.getResultList(); //得到集合返回类型        for (Object object : list) {            System.out.println(object);        }        tx.commit();    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><pre><code>//条件查询@Testpublic void findCondition () {    EntityManager em = null;    EntityTransaction tx = null;    try {        //获取实体管理对象        em = JPAUtil.getEntityManager();        //获取事务对象        tx = em.getTransaction();        tx.begin();        //创建query对象        String jpql = "from Student where perName like ? ";        Query query = em.createQuery(jpql);        //对占位符赋值，从1开始        query.setParameter(1, "张三%");        //查询并得到返回结果        Object object = query.getSingleResult(); //得到唯一的结果集对象        System.out.println(object);        tx.commit();    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><pre><code>//根据学生id倒序查询所有@Testpublic void testOrder() {    EntityManager em = null;    EntityTransaction tx = null;    try {        //获取实体管理对象        em = JPAUtil.getEntityManager();        //获取事务对象        tx = em.getTransaction();        tx.begin();        // 创建query对象        String jpql = "from Student order by perId desc";        Query query = em.createQuery(jpql);        // 查询并得到返回结果        List list = query.getResultList(); // 得到集合返回类型        for (Object object : list) {            System.out.println(object);        }        tx.commit();    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h3 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h3><pre><code>//统计查询@Testpublic void findCount() {    EntityManager em = null;    EntityTransaction tx = null;    try {        //获取实体管理对象        em = JPAUtil.getEntityManager();        //获取事务对象        tx = em.getTransaction();        tx.begin();        // 查询全部客户        // 1.创建query对象        String jpql = "select count(perId) from Student";        Query query = em.createQuery(jpql);        // 2.查询并得到返回结果        Object count = query.getSingleResult(); // 得到集合返回类型        System.out.println(count);        tx.commit();    } catch (Exception e) {        // 回滚事务        tx.rollback();        e.printStackTrace();    } finally {        // 释放资源        em.close();    }}</code></pre><h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！<br>  Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦</p><h2 id="Spring-Data-JPA-与-JPA和hibernate之间的关系"><a href="#Spring-Data-JPA-与-JPA和hibernate之间的关系" class="headerlink" title="Spring Data JPA 与 JPA和hibernate之间的关系"></a>Spring Data JPA 与 JPA和hibernate之间的关系</h2><p>  JPA是一套规范，内部是有接口和抽象类组成的。hibernate是一套成熟的ORM框架，而且Hibernate实现了JPA规范，所以也可以称hibernate为JPA的一种实现方式，我们使用JPA的API编程，意味着站在更高的角度上看待问题（面向接口编程）<br>  Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。</p><h2 id="Spring-Data-JPA案例"><a href="#Spring-Data-JPA案例" class="headerlink" title="Spring Data JPA案例"></a>Spring Data JPA案例</h2><h3 id="引入Spring-Data-JPA的坐标"><a href="#引入Spring-Data-JPA的坐标" class="headerlink" title="引入Spring Data JPA的坐标"></a>引入Spring Data JPA的坐标</h3><pre><code>    &lt;!-- 公共版本号 --&gt;    &lt;properties&gt;        &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;        &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt;        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;        &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt;        &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- junit单元测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.9&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- spring aspectj --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.6.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- hibernate --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;            &lt;version&gt;${hibernate.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;            &lt;version&gt;${hibernate.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;5.2.1.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- c3p0 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;c3p0&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;${c3p0.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;${log4j.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;${slf4j.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;${slf4j.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;${mysql.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;            &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 使用spring data jpa 必须引入 --&gt;        &lt;dependency&gt;              &lt;groupId&gt;javax.el&lt;/groupId&gt;              &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;              &lt;version&gt;2.2.4&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;              &lt;artifactId&gt;javax.el&lt;/artifactId&gt;              &lt;version&gt;2.2.4&lt;/version&gt;          &lt;/dependency&gt;     &lt;/dependencies&gt;</code></pre><h3 id="Spring整合Spring-Data-JPA"><a href="#Spring整合Spring-Data-JPA" class="headerlink" title="Spring整合Spring Data JPA"></a>Spring整合Spring Data JPA</h3><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"    xmlns:context="http://www.springframework.org/schema/context"    xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:tx="http://www.springframework.org/schema/tx"    xmlns:jpa="http://www.springframework.org/schema/data/jpa" xmlns:task="http://www.springframework.org/schema/task"    xsi:schemaLocation="        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/data/jpa         http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;    &lt;!-- 1.dataSource 配置数据库连接池--&gt;    &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;        &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt;        &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/jpa" /&gt;        &lt;property name="user" value="root" /&gt;        &lt;property name="password" value="rootroot" /&gt;    &lt;/bean&gt;    &lt;!-- 2.配置entityManagerFactory --&gt;    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;        &lt;property name="dataSource" ref="dataSource" /&gt;        &lt;!-- 配置扫描实体类所在的包 --&gt;        &lt;property name="packagesToScan" value="com.dzkj.domain" /&gt;        &lt;!--  jpa实现厂家 --&gt;        &lt;property name="persistenceProvider"&gt;            &lt;bean class="org.hibernate.jpa.HibernatePersistenceProvider" /&gt;        &lt;/property&gt;        &lt;!--JPA的供应商适配器--&gt;        &lt;property name="jpaVendorAdapter"&gt;            &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;                &lt;property name="generateDdl" value="false" /&gt;                &lt;property name="database" value="MYSQL" /&gt;                &lt;property name="databasePlatform" value="org.hibernate.dialect.MySQLDialect" /&gt;                &lt;property name="showSql" value="true" /&gt;            &lt;/bean&gt;        &lt;/property&gt;        &lt;property name="jpaDialect"&gt;            &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaDialect" /&gt;        &lt;/property&gt;         &lt;!--注入jpa的配置信息            加载jpa的基本配置信息和jpa实现方式（hibernate）的配置信息            hibernate.hbm2ddl.auto : 自动创建数据库表                create ： 每次都会重新创建数据库表                update：有表不会重新创建，没有表会重新创建表        --&gt;        &lt;property name="jpaProperties" &gt;            &lt;props&gt;                &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 3.事务管理器--&gt;    &lt;!-- JPA事务管理器  --&gt;    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;        &lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;    &lt;/bean&gt;    &lt;!-- 整合spring data jpa--&gt;    &lt;jpa:repositories base-package="com.dzkj.dao"        transaction-manager-ref="transactionManager"        entity-manager-factory-ref="entityManagerFactory"&gt;&lt;/jpa:repositories&gt;    &lt;!-- 4.声明式事务--&gt;    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name="save*" propagation="REQUIRED"/&gt;            &lt;tx:method name="insert*" propagation="REQUIRED"/&gt;            &lt;tx:method name="update*" propagation="REQUIRED"/&gt;            &lt;tx:method name="delete*" propagation="REQUIRED"/&gt;            &lt;tx:method name="get*" read-only="true"/&gt;            &lt;tx:method name="find*" read-only="true"/&gt;            &lt;tx:method name="*" propagation="REQUIRED"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 5.aop--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id="mypoint" expression="execution(* com.dzkj.service.*.*(..))" /&gt;        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="mypoint" /&gt;    &lt;/aop:config&gt;    &lt;context:component-scan base-package="com.dzkj"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;</code></pre><h3 id="JPA注解配置实体类映射关系"><a href="#JPA注解配置实体类映射关系" class="headerlink" title="JPA注解配置实体类映射关系"></a>JPA注解配置实体类映射关系</h3><pre><code>import javax.persistence.*;/***        * 所有的注解都是使用JPA的规范提供的注解， *        * 所以在导入注解包的时候，一定要导入javax.persistence下的 */@Entity@Table(name="per_student") //建立实体类和表的映射关系public class Student implements Serializable{    @Id//声明当前私有属性为主键    @GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略    @Column(name="per_id") //指定和表中per_id字段的映射关系    private Long perId;    @Column(name="per_name") //指定和表中per_name字段的映射关系    private String perName;    @Column(name="per_age")//指定和表中per_age字段的映射关系    private int perAge;    @Column(name="per_sex")//指定和表中per_sex字段的映射关系    private String perSex;    @Column(name="per_major")//指定和表中per_major字段的映射关系    private String perMajor;    @Column(name="per_phone")//指定和表中per_phone字段的映射关系    private String perPhone;    public Long getPerId() {        return perId;    }    public void setPerId(Long perId) {        this.perId = perId;    }    public String getPerName() {        return perName;    }    public void setPerName(String perName) {        this.perName = perName;    }    public int getPerAge() {        return perAge;    }    public void setPerAge(int perAge) {        this.perAge = perAge;    }    public String getPerSex() {        return perSex;    }    public void setPerSex(String perSex) {        this.perSex = perSex;    }    public String getPerMajor() {        return perMajor;    }    public void setPerMajor(String perMajor) {        this.perMajor = perMajor;    }    public String getPerPhone() {        return perPhone;    }    public void setPerPhone(String perPhone) {        this.perPhone = perPhone;    }}</code></pre><h3 id="编写Spring-Data-JPA规范的Dao层接口"><a href="#编写Spring-Data-JPA规范的Dao层接口" class="headerlink" title="编写Spring Data JPA规范的Dao层接口"></a>编写Spring Data JPA规范的Dao层接口</h3><p>1.创建一个Dao层接口，并实现JpaRepository和JpaSpecificationExecutor<br>2.提供相应的泛型</p><pre><code>import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import com.dzkj.Student;/** * JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作 * JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作） */public interface StudentDao extends JpaRepository&lt;Student, Long&gt;, JpaSpecificationExecutor&lt;Student&gt; {}</code></pre><h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext.xml")public class StudenDaoTest {    @Autowired    private StudentDao studentDao;    /**     * 添加学生：调用save(obj)方法     */    @Test    public void testSave() {        Student c = new Student();        c.setperName("李四");        studentDao.save(c);    }    /**     * 修改学生：调用save(obj)方法     * 对于save方法的解释：如果执行此方法是对象中存在id属性，即为更新操作会先根据id查询，再更新         *                    如果执行此方法中对象中不存在id属性，即为保存操作       */    @Test    public void testUpdate() {        //根据id查询id为1的学生        Student student = studentDao.findOne(1l);        //修改学生名称        student.setCustName("张三");        //更新        studentDao.save(student);    }    /**     * 根据id删除：调用delete(id)方法     */    @Test    public void testDelete() {        studentDao.delete(1l);    }    /**     * 根据id查询：调用findOne(id)方法     */    @Test    public void testFindById() {        Student student = studentDao.findOne(2l);        System.out.println(student);    }}</code></pre><h2 id="spring内部原理"><a href="#spring内部原理" class="headerlink" title="spring内部原理"></a>spring内部原理</h2><p><a href="https://blog.csdn.net/andy_zhang2007/article/details/84064862?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Spring Data JPA 工作原理 : 自定义JpaRespository接口却不用提供实现</a></p><h2 id="JPQL的方式查询"><a href="#JPQL的方式查询" class="headerlink" title="JPQL的方式查询"></a>JPQL的方式查询</h2><p>  使用Spring Data JPA提供的查询方法已经可以解决大部分的应用场景，对于某些业务来说，还需要灵活的构造查询条件，这时就可以使用@Query注解，结合JPQL的语句方式完成查询,@Query 只需在方法上面标注该注解，同时提供一个JPQL查询语句,使用时调用该方法就可以了</p><pre><code>public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;,JpaSpecificationExecutor&lt;Customer&gt; {        //@Query 使用jpql的方式查询所有。    @Query(value="from Student")    public List&lt;Student&gt; findAllStudent();    //@Query 使用jpql的方式查询。?1代表参数的占位符，其中1对应方法中的参数索引    @Query(value="from Student where perName = ?1")    public Student findStudent(String perName);    //在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，框架最终会生成一个更新的操作，而非查询    @Query(value="update Student set perName = ?1 where perId = ?2")    @Modifying    public void updateStudent(String perName,Long perId);}</code></pre><h2 id="SQL语句查询"><a href="#SQL语句查询" class="headerlink" title="SQL语句查询"></a>SQL语句查询</h2><pre><code>    /**     * nativeQuery ：false（使用jpql查询） | true（使用本地查询：sql查询）     * 默认jpql查询     */    @Query(value="select * from per_student",nativeQuery=true)    public void findSql();</code></pre><h2 id="方法命名规则查询"><a href="#方法命名规则查询" class="headerlink" title="方法命名规则查询"></a>方法命名规则查询</h2><p>  需要按照Spring Data JPA提供的方法命名规则定义方法的名称，Spring Data JPA在程序执行的时候会根据方法名称进行解析，并自动生成查询语句进行查询</p><pre><code>按照Spring Data JPA 定义的规则，查询方法以findBy开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析。</code></pre><pre><code>//方法命名方式查询（根据客户名称查询客户）    public Customer findByPerName(String perName);</code></pre><p>具体的关键字，使用方法和生产成SQL如下表所示</p><table><thead><tr><th align="center">: Keyword :</th><th align="center">: Sample :</th><th align="center">: JPQL :</th></tr></thead><tbody><tr><td align="center">:And:</td><td align="center">:findByLastnameAndFirstname:</td><td align="center">:… where x.lastname = ?1 and x.firstname = ?2:</td></tr><tr><td align="center">:Or:</td><td align="center">:findByLastnameOrFirstname:</td><td align="center">:… where x.lastname = ?1 or x.firstname = ?2:</td></tr><tr><td align="center">:Is,Equals    :</td><td align="center">: findByFirstnameIs,findByFirstnameEquals    :</td><td align="center">:… where x.firstname = ?1:</td></tr><tr><td align="center">:Between:</td><td align="center">:findByStartDateBetween:</td><td align="center">:… where x.startDate between ?1 and ?2:</td></tr><tr><td align="center">:LessThan:</td><td align="center">:findByAgeLessThan:</td><td align="center">:… where x.age &lt; ?1:</td></tr><tr><td align="center">:LessThanEqual:</td><td align="center">:findByAgeLessThanEqual:</td><td align="center">:… where x.age ⇐ ?1:</td></tr><tr><td align="center">:GreaterThan:</td><td align="center">:findByAgeGreaterThan:</td><td align="center">:… where x.age &gt; ?1:</td></tr><tr><td align="center">:GreaterThanEqual:</td><td align="center">:findByAgeGreaterThanEqual:</td><td align="center">:… where x.age &gt;= ?1:</td></tr><tr><td align="center">:After:</td><td align="center">:findByStartDateAfter:</td><td align="center">:… where x.startDate &gt; ?1:</td></tr><tr><td align="center">:Before:</td><td align="center">:findByStartDateBefore:</td><td align="center">:… where x.startDate &lt; ?1:</td></tr><tr><td align="center">:IsNull:</td><td align="center">:findByAgeIsNull:</td><td align="center">:… where x.age is null:</td></tr><tr><td align="center">:IsNotNull,NotNull:</td><td align="center">:findByAge(Is)NotNull:</td><td align="center">:… where x.age not null:</td></tr><tr><td align="center">:Like:</td><td align="center">:findByFirstnameLike:</td><td align="center">:… where x.firstname like ?1:</td></tr><tr><td align="center">:NotLike:</td><td align="center">:findByFirstnameNotLike:</td><td align="center">:… where x.firstname not like ?1:</td></tr><tr><td align="center">:StartingWith:</td><td align="center">:findByFirstnameStartingWith:</td><td align="center">:… where x.firstname like ?1 (parameter bound with appended %):</td></tr><tr><td align="center">:EndingWith:</td><td align="center">:findByFirstnameEndingWith:</td><td align="center">:… where x.firstname like ?1 (parameter bound with prepended %):</td></tr><tr><td align="center">:Containing:</td><td align="center">:findByFirstnameContaining:</td><td align="center">:… where x.firstname like ?1 (parameter bound wrapped in %):</td></tr><tr><td align="center">:OrderBy:</td><td align="center">:findByAgeOrderByLastnameDesc:</td><td align="center">:… where x.age = ?1 order by x.lastname desc:</td></tr><tr><td align="center">:Not:</td><td align="center">:findByLastnameNot:</td><td align="center">:… where x.lastname &lt;&gt; ?1:</td></tr><tr><td align="center">:In:</td><td align="center">:findByAgeIn(Collection ages):</td><td align="center">:… where x.age in ?1:</td></tr><tr><td align="center">:NotIn:</td><td align="center">:findByAgeNotIn(Collection age):</td><td align="center">:… where x.age not in ?1:</td></tr><tr><td align="center">:TRUE:</td><td align="center">:findByActiveTrue():</td><td align="center">:… where x.active = true:</td></tr><tr><td align="center">:FALSE:</td><td align="center">:findByActiveFalse():</td><td align="center">:… where x.active = false:</td></tr><tr><td align="center">:IgnoreCase:</td><td align="center">:findByFirstnameIgnoreCase:</td><td align="center">:… where UPPER(x.firstame) = UPPER(?1):</td></tr></tbody></table><hr><h1 id="Specifications动态查询"><a href="#Specifications动态查询" class="headerlink" title="Specifications动态查询"></a>Specifications动态查询</h1><p>当查询某个实体的时候，给定的条件是不固定的，就需要动态构建相应的查询语句，在Spring Data JPA中可以通过JpaSpecificationExecutor接口查询。相比JPQL,其优势是类型安全,更加的面向对象。</p><h3 id="Specifications-条件查询"><a href="#Specifications-条件查询" class="headerlink" title="Specifications 条件查询"></a>Specifications 条件查询</h3><pre><code>//依赖注入customerDao    @Autowired    private StudentDao studentDao;        @Test    public void testSpecifications() {          //使用匿名内部类的方式，创建一个Specification的实现类，并实现toPredicate方法        /**        *    root    ：Root接口，代表查询的根对象，可以通过root获取实体中的属性        *    query    ：代表一个顶层查询对象，用来自定义查询        *    cb        ：用来构建查询，此对象里有很多条件方法        **/        Specification &lt;Student&gt; spec = new Specification&lt;Student&gt;() {            public Predicate toPredicate(Root&lt;Student&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {                //cb:构建查询，添加查询方式   like：模糊匹配                //root：从实体Customer对象中按照custName属性进行查询                return cb.like(root.get("perName").as(String.class), "张三");            }        };        Student student = studentDao.findOne(spec);        System.out.println(student);    }</code></pre><h3 id="Specifications-分页查询"><a href="#Specifications-分页查询" class="headerlink" title="Specifications 分页查询"></a>Specifications 分页查询</h3><pre><code>@Test    public void testPage() {        //构造查询条件        Specification&lt;Student&gt; spec = new Specification&lt;Student&gt;() {            public Predicate toPredicate(Root&lt;Student&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {                return cb.like(root.get("perName").as(String.class), "张三%");            }        };        /**         * 构造分页参数         *         Pageable : 接口         *             PageRequest实现了Pageable接口，调用构造方法的形式构造         *                 第一个参数：页码（从0开始）         *                 第二个参数：每页查询条数         */        Pageable pageable = new PageRequest(0, 5);        /**         * 分页查询，封装为Spring Data Jpa 内部的page bean         *         此重载的findAll方法为分页方法需要两个参数         *             第一个参数：查询条件Specification         *             第二个参数：分页参数         */        Page&lt;Student&gt; page = studentDao.findAll(spec,pageable);        /**        //获取总页数        page.getTotalPages();        //获取总记录数            page.getTotalElements();        //获取列表数据        page.getContent();        */    }</code></pre><h2 id="映射的注解说明"><a href="#映射的注解说明" class="headerlink" title="映射的注解说明"></a>映射的注解说明</h2><blockquote><p>@OneToMany:<br>      作用：建立一对多的关系映射<br>   属性：<br>       targetEntityClass：指定多的多方的类的字节码<br>       mappedBy：指定从表实体类中引用主表对象的名称。<br>       cascade：指定要使用的级联操作<br>       fetch：指定是否采用延迟加载<br>       orphanRemoval：是否使用孤儿删除</p><p>@ManyToOne<br>   作用：建立多对一的关系<br>   属性：<br>       targetEntityClass：指定一的一方实体类字节码<br>       cascade：指定要使用的级联操作<br>       fetch：指定是否采用延迟加载<br>       optional：关联是否可选。如果设置为false，则必须始终存在非空关系。</p><p>@JoinColumn<br>    作用：用于定义主键字段和外键字段的对应关系。<br>    属性：<br>       name：指定外键字段的名称<br>       referencedColumnName：指定引用主表的主键字段名称<br>       unique：是否唯一。默认值不唯一<br>       nullable：是否允许为空。默认值允许。<br>       insertable：是否允许插入。默认值允许。<br>       updatable：是否允许更新。默认值允许。<br>       columnDefinition：列的定义信息。</p></blockquote><h1 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h1><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><h3 id="数据库关系的建立"><a href="#数据库关系的建立" class="headerlink" title="数据库关系的建立"></a>数据库关系的建立</h3><p>可以不用创建数据库表 借助springdatajpa的机制自动创建表，在配置文件中添加</p><pre><code>&lt;property name="jpaProperties" &gt;    &lt;props&gt;        &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;</code></pre><pre><code>CREATE TABLE  per_teacher(      tea_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '老师编号(主键)',      tea_name varchar(32) NOT NULL COMMENT '老师姓名',      tea_age int DEFAULT NULL COMMENT '老师年龄',      tea_sex varchar(2) DEFAULT NULL COMMENT '老师性别',      tea_major varchar(32) DEFAULT NULL COMMENT '授课专业',      tea_phone varchar(64) DEFAULT NULL COMMENT '老师联系电话',            PRIMARY KEY (`tea_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE per_student (      per_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '学生编号(主键)',      per_name varchar(32) NOT NULL COMMENT '学生姓名',      per_age int DEFAULT NULL COMMENT '学生年龄',      per_sex varchar(2) DEFAULT NULL COMMENT '学生性别',      per_major varchar(32) DEFAULT NULL COMMENT '学生专业',      per_phone varchar(64) DEFAULT NULL COMMENT '学生联系电话',            per_tea_id bigint(32) NOT NULL COMMENT '老师编号(外键)',      PRIMARY KEY (`per_id`),            foreign key(per_tea_id) references per_Teacher(tea_id)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><h3 id="实体类关系建立"><a href="#实体类关系建立" class="headerlink" title="实体类关系建立"></a>实体类关系建立</h3><p>老师实体类</p><pre><code>import java.util.HashSet;import java.util.Set;import javax.persistence.*;@Entity//表示当前类是一个实体类@Table(name="per_teacher")//建立当前实体类和表之间的对应关系public class Teacher {    @Id//表明当前私有属性是主键    @GeneratedValue(strategy=GenerationType.IDENTITY)//指定主键的生成策略    @Column(name="tea_id")//指定和数据库表中的cust_id列对应    private Long teaId;    @Column(name="tea_name")    private String teaName;    @Column(name="tea_age")    private int teaAge;    @Column(name="tea_sex")    private String teaSex;    @Column(name="tea_major")    private String teaMajor;    @Column(name="tea_phone")    private String teaPhone;    //设置了双向关系后，会发送两条insert语句，一条多余的update语句，解决思路就是一方放弃维护权    @OneToMany(mappedBy="teacher",cascade = CascadeType.ALL)    private Set&lt;Student&gt; students = new HashSet&lt;&gt;();    public Long getTeaId() {        return teaId;    }    public void setTeaId(Long teaId) {        this.teaId = teaId;    }    public String getTeaName() {        return teaName;    }    public void setTeaName(String teaName) {        this.teaName = teaName;    }    public int getTeaAge() {        return teaAge;    }    public void setTeaAge(int teaAge) {        this.teaAge = teaAge;    }    public String getTeaSex() {        return teaSex;    }    public void setTeaSex(String teaSex) {        this.teaSex = teaSex;    }    public String getTeaMajor() {        return teaMajor;    }    public void setTeaMajor(String teaMajor) {        this.teaMajor = teaMajor;    }    public String getTeaPhone() {        return teaPhone;    }    public void setTeaPhone(String teaPhone) {        this.teaPhone = teaPhone;    }    public Set&lt;Student&gt; getStudents() {        return students;    }    public void setStudents(Set&lt;Student&gt; students) {        this.students = students;    }    @Override    public String toString() {        return "Teacher [teaId=" + teaId + ", teaName=" + teaName + ", teaAge=" + teaAge + ", teaSex=" + teaSex                + ", teaMajor=" + teaMajor + ", teaPhone=" + teaPhone + ", students=" + students + "]";    }}</code></pre><p>学生实体类</p><pre><code>import java.io.Serializable;import javax.persistence.*;@Entity@Table(name="per_student") //建立实体类和表的映射关系public class Student implements Serializable{    @Id//声明当前私有属性为主键    @GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略    @Column(name="per_id") //指定和表中per_id字段的映射关系    private Long perId;    @Column(name="per_name") //指定和表中per_name字段的映射关系    private String perName;    @Column(name="per_age")//指定和表中per_age字段的映射关系    private int perAge;    @Column(name="per_sex")//指定和表中per_sex字段的映射关系    private String perSex;    @Column(name="per_major")//指定和表中per_major字段的映射关系    private String perMajor;    @Column(name="per_phone")//指定和表中per_phone字段的映射关系    private String perPhone;    //多对一关系映射：多个学生对应老师    @ManyToOne(targetEntity=Teacher.class)    @JoinColumn(name="per_tea_id",referencedColumnName="tea_id")    private Teacher teacher;    public Long getPerId() {        return perId;    }    public void setPerId(Long perId) {        this.perId = perId;    }    public String getPerName() {        return perName;    }    public void setPerName(String perName) {        this.perName = perName;    }    public int getPerAge() {        return perAge;    }    public void setPerAge(int perAge) {        this.perAge = perAge;    }    public String getPerSex() {        return perSex;    }    public void setPerSex(String perSex) {        this.perSex = perSex;    }    public String getPerMajor() {        return perMajor;    }    public void setPerMajor(String perMajor) {        this.perMajor = perMajor;    }    public String getPerPhone() {        return perPhone;    }    public void setPerPhone(String perPhone) {        this.perPhone = perPhone;    }    public Teacher getTeacher() {        return teacher;    }    public void setTeacher(Teacher teacher) {        this.teacher = teacher;    }    @Override    public String toString() {        return "Student [perId=" + perId + ", perName=" + perName + ", perAge=" + perAge + ", perSex=" + perSex                + ", perMajor=" + perMajor + ", perPhone=" + perPhone + ", teacher=" + teacher + "]";    }}</code></pre><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><pre><code>import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.dzkj.dao.StudentDao;import com.dzkj.dao.TeacherDao;import com.dzkj.domain.Student;import com.dzkj.domain.Teacher;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext.xml")public class OneToManyTest {    @Autowired    private TeacherDao teacherDao;    @Autowired    private StudentDao studentDao;    @Test    @Transactional  //开启事务    @Rollback(false)//设置为不回滚    public void testAdd() {        Teacher t = new Teacher();        t.setTeaName("王老师");        t.setTeaAge(23);        t.setTeaSex("男");        t.setTeaMajor("java开发");        t.setTeaPhone("17856520899");        Student s = new Student();        s.setPerName("张三");        s.setPerAge(18);        s.setPerSex("男");        s.setPerMajor("java开发攻城狮");        s.setPerPhone("17856520896");        t.getStudents().add(s);        s.setTeacher(t);        teacherDao.save(t);        studentDao.save(s);    }</code></pre><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><blockquote><p>有从表数据<br> 1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表结构上，外键字段有非空约束，默认情况就会报错&gt;了。<br> 2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null，        没有关系）因为在删除时，它根本不会去更&gt;新从表的外键字段了。<br> 3、如果还想删除，使用级联删除引用</p><p>没有从表数据引用：随便删</p></blockquote><pre><code>@Autowiredprivate CustomerDao customerDao;@Test@Transactional@Rollback(false)//设置为不回滚public void testDelete() {    customerDao.delete(1l);}</code></pre><h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><pre><code>    /**     * cascade:配置级联操作     *         CascadeType.MERGE    级联更新     *         CascadeType.PERSIST    级联保存：     *         CascadeType.REFRESH 级联刷新：     *         CascadeType.REMOVE    级联删除：     *         CascadeType.ALL        包含所有     */    @OneToMany(mappedBy="Teacher",cascade=CascadeType.ALL)</code></pre><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><h3 id="实体类关系配置"><a href="#实体类关系配置" class="headerlink" title="实体类关系配置"></a>实体类关系配置</h3><p>用户实体类</p><pre><code>/** * 用户的数据模型 */@Entity@Table(name="sys_user")public class SysUser implements Serializable {    @Id    @GeneratedValue(strategy=GenerationType.IDENTITY)    @Column(name="user_id")    private Long userId;    @Column(name="user_code")    private String userCode;    @Column(name="user_name")    private String userName;    @Column(name="user_password")    private String userPassword;    @Column(name="user_state")    private String userState;    //多对多关系映射    @ManyToMany(mappedBy="users")    private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0);    public Long getUserId() {        return userId;    }    public void setUserId(Long userId) {        this.userId = userId;    }    public String getUserCode() {        return userCode;    }    public void setUserCode(String userCode) {        this.userCode = userCode;    }    public String getUserName() {        return userName;    }    public void setUserName(String userName) {        this.userName = userName;    }    public String getUserPassword() {        return userPassword;    }    public void setUserPassword(String userPassword) {        this.userPassword = userPassword;    }    public String getUserState() {        return userState;    }    public void setUserState(String userState) {        this.userState = userState;    }    public Set&lt;SysRole&gt; getRoles() {        return roles;    }    public void setRoles(Set&lt;SysRole&gt; roles) {        this.roles = roles;    }    @Override    public String toString() {        return "SysUser [userId=" + userId + ", userCode=" + userCode + ", userName=" + userName + ", userPassword="                + userPassword + ", userState=" + userState + "]";    }}</code></pre><p>角色实体类</p><pre><code>/** * 角色的数据模型 */@Entity@Table(name="sys_role")public class SysRole implements Serializable {    @Id    @GeneratedValue(strategy=GenerationType.IDENTITY)    @Column(name="role_id")    private Long roleId;    @Column(name="role_name")    private String roleName;    @Column(name="role_memo")    private String roleMemo;    //多对多关系映射    @ManyToMany    @JoinTable(name="user_role_rel",//中间表的名称              //中间表user_role_rel字段关联sys_role表的主键字段role_id              joinColumns={@JoinColumn(name="role_id",referencedColumnName="role_id")},              //中间表user_role_rel的字段关联sys_user表的主键user_id              inverseJoinColumns={@JoinColumn(name="user_id",referencedColumnName="user_id")}    )    private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0);    public Long getRoleId() {        return roleId;    }    public void setRoleId(Long roleId) {        this.roleId = roleId;    }    public String getRoleName() {        return roleName;    }    public void setRoleName(String roleName) {        this.roleName = roleName;    }    public String getRoleMemo() {        return roleMemo;    }    public void setRoleMemo(String roleMemo) {        this.roleMemo = roleMemo;    }    public Set&lt;SysUser&gt; getUsers() {        return users;    }    public void setUsers(Set&lt;SysUser&gt; users) {        this.users = users;    }    @Override    public String toString() {        return "SysRole [roleId=" + roleId + ", roleName=" + roleName + ", roleMemo=" + roleMemo + "]";    }}</code></pre><h3 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h3><pre><code>@Autowired    private UserDao userDao;    @Autowired    private RoleDao roleDao;    /**     * 需求：     *     保存用户和角色     * 要求：     *     创建2个用户和3个角色     *     让1号用户具有1号和2号角色(双向的)     *     让2号用户具有2号和3号角色(双向的)     *  保存用户和角色     * 问题：     *  在保存时，会出现主键重复的错误，因为都是要往中间表中保存数据造成的。     * 解决办法：     *     让任意一方放弃维护关联关系的权利     */    @Test    @Transactional  //开启事务    @Rollback(false)//设置为不回滚    public void test1(){        //创建对象        SysUser u1 = new SysUser();        u1.setUserName("用户1");        SysRole r1 = new SysRole();        r1.setRoleName("角色1");        //建立关联关系        u1.getRoles().add(r1);        r1.getUsers().add(u1);        //保存        roleDao.save(r1);        userDao.save(u1);    }</code></pre><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><pre><code>@Autowired    private UserDao userDao;    /**     * 删除操作     *     在多对多的删除时，双向级联删除根本不能配置     * 禁用     *    如果配了的话，如果数据之间有相互引用关系，可能会清空所有数据     */    @Test    @Transactional    @Rollback(false)//设置为不回滚    public void testDelete() {        userDao.delete(1l);    }</code></pre><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。例如：我们通过ID查询方式查出一个老师，可以调用Teacher类中的getLinkMans()方法来获取该客户的所有联系人。对象导航查询的使用要求是：两个对象之间必须存在关联关系。</p><p>查询一个老师，获取该老师的所有学生</p><pre><code>@Autowired    private CustomerDao customerDao;    @Test    //由于是在java代码中测试，为了解决no session问题，将操作配置到同一个事务中    @Transactional     public void testFind() {        Teacher teacher = teacherDao.findOne(5l);        Set&lt;Student&gt; Students = teacher.getStudents();//对象导航查询        for(Student student : Students) {              System.out.println(student);        }    }</code></pre><p>查询一个学生，获取该学生的所有老师</p><pre><code>@Autowired    private StudentDao studentDao;    @Test    public void testFind() {        Student Student = studentDao.findOne(4l);        Teacher teacher = Student.getTeacher(); //对象导航查询        System.out.println(teacher);    }</code></pre><p>查询学生时，肯定会看看该学生的专业老师。如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的话，一个对象不会消耗太多的内存。而且多数情况下我们都是要使用的<br>** 解决： 采用立即加载的思想。通过配置的方式来设定，只要查询从表实体，就把主表实体对象同时查出来 **</p><pre><code>/**     * 在联系人对象的@ManyToOne注解中添加fetch属性     *         FetchType.EAGER    ：立即加载     *         FetchType.LAZY    ：延迟加载     */    @ManyToOne(targetEntity=Teacher.class,fetch=FetchType.EAGER)    @JoinColumn(name="per_tea_id",referencedColumnName="tea_id")    private Teacher teacher;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
            <tag> springdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习记录</title>
      <link href="/2020/03/21/redissum/"/>
      <url>/2020/03/21/redissum/</url>
      
        <content type="html"><![CDATA[<h1 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h1><pre><code>Redis：开源、免费、高性能、K-V数据库、内存数据库、非关系型数据库，支持持久化、集群和事务</code></pre><a id="more"></a><p><a href="https://www.cnblogs.com/heqiuyong/p/10463334.html" target="_blank" rel="noopener">Centos7 安装redis</a></p><p><a href="https://www.cnblogs.com/niuben/p/11307406.html" target="_blank" rel="noopener">Redis 连接时报错：Could not connect to Redis at 127.0.0.1:6379: Connection refused</a></p><p><a href="https://www.cnblogs.com/cloudshadow/p/redis_connect_error.html" target="_blank" rel="noopener">redis Connection refused 远程连接错误</a></p><p><a href="https://www.pianshen.com/article/4494275757/" target="_blank" rel="noopener">redis 密码设置</a></p><p><a href="https://blog.csdn.net/lady132/article/details/90041258?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">SSM 整合Redis</a></p><h1 id="Redis开启"><a href="#Redis开启" class="headerlink" title="Redis开启"></a>Redis开启</h1><h3 id="开启服务："><a href="#开启服务：" class="headerlink" title="开启服务："></a>开启服务：</h3><p><code>redis-server  redis.conf</code></p><h3 id="启动客户端："><a href="#启动客户端：" class="headerlink" title="启动客户端："></a>启动客户端：</h3><p><code>redis-cli</code></p><h3 id="重启redis："><a href="#重启redis：" class="headerlink" title="重启redis："></a>重启redis：</h3><p><code>sudo service redis restart</code></p><h1 id="Redis关闭"><a href="#Redis关闭" class="headerlink" title="Redis关闭"></a>Redis关闭</h1><p><strong>第一种关闭方式：（断电、非正常关闭。容易丢失数据）</strong><br>查询启动进程 根据要关闭的端口关闭相应服务</p><pre><code>$ ps -ef | grep -i redis    ···$ Kill -9 PID</code></pre><p><strong>第二种方式（正常关闭、数据保存）</strong><br><code>shutdown</code></p><h1 id="key的命名建议"><a href="#key的命名建议" class="headerlink" title="key的命名建议"></a>key的命名建议</h1><ol><li>key不要太长，尽量不要超过1024字节。不仅消耗内存，也会降低查找的效率</li><li>key不要太短，太短可读性会降低</li><li>在一个项目中，key最好使用统一的命名模式，如user:123:password</li><li>key区分大小写</li></ol><h1 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h1><blockquote><p>DEL key：删除指定key<br>DUMP key：序列化给定key，返回被序列化的值<br>EXISTS key：检查key是否存在<br>EXPIRE key second：为key设定过期时间<br>TTL key：返回key剩余时间<br>PERSIST key：移除key的过期时间，key将持久保存<br>KEY pattern：查询所有符号给定模式的key<br>RANDOM key：随机返回一个key<br>RANAME key newkey：修改key的名称<br>MOVE key db：移动key至指定数据库中<br>TYPE key：返回key所储存的值的类型<br>Select :切换到指定数据库（redis默认16个库，从0-15，使用时需要指定数据库-1）<br>DBSIZE :查看当前数据库的key的数量<br>Keys 查看当前数据库的所有key<br>FLUSHDB 删除当前数据库的所有key<br>FLUSHALL 删除所有数据库的所有key</p></blockquote><h1 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h1><h2 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code>string类型是二进制安全的，redis的string可以包含任何数据，如图像、序列化对象。一个键最多能存储512MB。==二进制安全是指，在传输数据的时候，能保证二进制数据的信息安全，也就是不会被篡改、破译；如果被攻击，能够及时检测出来 ==</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote><p>Incr<br>    语法：incr key<br>    将key中的数字值加1，如果key不存在，则key的值先被初始化为0再执行incr操作（只能对数值类型数据操作）</p><p>Decr<br>    语法：decr key<br>    将key中的数字值减</p><p>Append<br>    语法：decr key value<br>    在value值后面追加，如果不存在，为其赋值</p><p>Strlen<br>    语法： strlen key<br>    返回key字符串的长度，如果key存在就返回长度，不存在就返回0</p><p>Getrange<br>    语法：getrange key star end<br>    获取key中字符串值从start开始到end的子串</p><p>Setrange<br>    语法： setrange key offset value<br>    用value替换key的存储的值从offset开始，不存在的key做空白字符串，返回修改后的字符串长度</p><p>Mset<br>    语法：mset key value[key value…]<br>    同时设置一个或多个key-value对</p><p>Mget<br>    语法：mget key[key…]<br>    获取给定key的所有值</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>String通常用于保存单个字符串或JSON字符串数据</li><li>因为String是二进制安全的，所以可以把保密要求高的图片文件内容作为字符串来存储</li><li>计数器：常规Key-Value缓存应用，如微博数、粉丝数。INCR本身就具有原子性特性，所以不会有线程安全问题</li></ol><hr><h2 id="链表list"><a href="#链表list" class="headerlink" title="链表list"></a>链表list</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><pre><code>Redis的list类型其实就是一个每个子元素都是string类型的双向链表，链表的最大长度是2^32。list既可以用做栈，也可以用做队列。类似于Java中的LinkedList。list的pop操作还有阻塞版本，主要是为了避免轮询</code></pre><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote><p>（1）lpush key value：把值插入到链表头部<br>（2）rpush key value：把值插入到链表尾部<br>（3）lpop key ：返回并删除链表头部元素<br>（4）rpop key： 返回并删除链表尾部元素<br>（5）lrange key start stop：返回链表中[start, stop]中的元素<br>（6）lrem key count value：从链表中删除value值，删除count的绝对值个value后结束<br>　　　　　　　count &gt; 0 从表头删除　　count &lt; 0 从表尾删除　　count=0 全部删除<br>（7）ltrim key start stop：剪切key对应的链接，切[start, stop]一段并把改制重新赋给key<br>（8）lindex key index：返回index索引上的值<br>（9）llen key：计算链表的元素个数<br>（10）linsert key after|before search value：在key 链表中寻找search，并在search值之前|之后插入value<br>（11）rpoplpush source dest：把source 的末尾拿出，放到dest头部，并返回单元值<br>（12）brpop，blpop key timeout：等待弹出key的尾/头元素，timeout为等待超时时间，如果timeout为0则一直等待下去</p></blockquote><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>对数据大的集合数据删减<br> 列表显示、关注列表、粉丝列表、留言评价…分页、热点新闻等</li><li>任务队列<br> list通常用来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样通过order by来排序。长轮询ajax，在线聊天等。</li></ol><blockquote><p>补充：<br>task + bak 双链表完成安全队列<br>业务逻辑： rpoplpush task bak<br>　　　　　　　　接收返回值并做业务处理<br>　 　　　　　　　如果成功则rpop bak清除任务，如果不成功，下次从bak表取任务</p></blockquote><hr><h2 id="哈希hash"><a href="#哈希hash" class="headerlink" title="哈希hash"></a>哈希hash</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><pre><code>Redis hash 是一个string类型的field和value的映射表，它的添加、删除操作都是O(1)（平均）。hash特别适用于存储对象，将一个对象存储在hash类型中会占用更少的内存，并且可以方便的存取整个对象。</code></pre><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote><p>配置：hash_max_zipmap_entries 64 #配置字段最多64个<br>　　　hash_max_zipmap_value 512 #配置value最大为512字节<br>（1）hset myhash field value：设置myhash的field为value<br>（2）hsetnx myhash field value：不存在的情况下设置myhash的field为value<br>（3）hmset myhash field1 value1 field2 value2：同时设置多个field<br>（4）hget myhash field：获取指定的hash field<br>（5）hmget myhash field1 field2：一次获取多个field<br>（6）hincrby myhash field 5：指定的hash field加上给定的值<br>（7）hexists myhash field：测试指定的field是否存在<br>（8）hlen myhash：返回hash的field数量<br>（9）hdel myhash field：删除指定的field<br>（10）hkeys myhash：返回hash所有的field<br>（11）hvals myhash：返回hash所有的value<br>（12）hgetall myhash：获取某个hash中全部的field及value　</p></blockquote><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>  Hash的应用场景，通常用来存储一个用户信息的对象数据。</p><ol><li>相比于存储对象的string类型的json串，json串修改单个属性需要将整个值取出来。而hash不需要。</li><li>相比于多个key-value存储对象，hash节省了很多内存空间</li><li>如果hash的属性值被删除完，那么hash的key也会被redis删除</li></ol><hr><h2 id="集合结构set"><a href="#集合结构set" class="headerlink" title="集合结构set"></a>集合结构set</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><pre><code>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，set是通过hashtable实现的 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 类似于JAVA中的 Hashtable集合，具有无序性、确定性、唯一性等特点</code></pre><p>　</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令　"></a>常用命令　</h3><blockquote><p>（1）sadd key value1 value2：往集合里面添加元素<br>（2）smembers key：获取集合所有的元素<br>（3）srem key value：删除集合某个元素<br>（4）spop key：返回并删除集合中1个随机元素（可以坐抽奖，不会重复抽到某人）　　　<br>（5）srandmember key：随机取一个元素<br>（6）sismember key value：判断集合是否有某个值<br>（7）scard key：返回集合元素的个数<br>（8）smove source dest value：把source的value移动到dest集合中<br>（9）sinter key1 key2 key3：求key1 key2 key3的交集<br>（10）sunion key1 key2：求key1 key2 的并集<br>（11）sdiff key1 key2：求key1 key2的差集<br>（12）sinterstore res key1 key2：求key1 key2的交集并存在res里　</p></blockquote><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>  对两个集合间的数据[计算]进行交集、并集、差集运算</p><ol><li>以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。</li><li>利用唯一性，可以统计访问网站的所有独立 IP</li></ol><hr><h2 id="有序集合zset"><a href="#有序集合zset" class="headerlink" title="有序集合zset"></a>有序集合zset</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><pre><code>它是在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动按新的值调整顺序。可以理解为有两列的mysql表，一列存储value，一列存储顺序，操作中key理解为zset的名字。</code></pre><p>　　当元素被添加到集合中时，一个元素到score的映射被添加到hashtable中，所以给定一个元素获取score的开销是O(1)。另一个score到元素的映射被添加的skiplist，并按照score排序，所以就可以有序地获取集合中的元素。添加、删除操作开销都是O(logN)和skiplist的开销一致，redis的skiplist 实现是双向链表，这样就可以逆序从尾部去元素。sortedset最经常使用方式应该就是作为索引来使用，我们可以把要排序的字段作为score存储，对象的ID当元素存储。有序且不重复。每个元素都会关联一个double类型的分数，Redis通过分数进行从小到大的排序。分数可以重复</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令　　"></a>常用命令　　</h3><blockquote><p>（1）zadd key score1 value1：添加元素<br>（2）zrange key start stop [withscore]：把集合排序后,返回名次[start,stop]的元素  默认是升续排列  withscores 是把score也打印出来<br>（3）zrank key member：查询member的排名（升序0名开始）<br>（4）zrangebyscore key min max [withscores] limit offset N：集合（升序）排序后取score在[min, max]内的元素，并跳过offset个，取出N个<br>（5）zrevrank key member：查询member排名（降序 0名开始）<br>（6）zremrangebyscore key min max：按照score来删除元素，删除score在[min, max]之间<br>（7）zrem key value1 value2：删除集合中的元素<br>（8）zremrangebyrank key start end：按排名删除元素，删除名次在[start, end]之间的<br>（9）zcard key：返回集合元素的个数<br>（10）zcount key min max：返回[min, max]区间内元素数量<br>（11）zinterstore dest numkeys key1[key2..] [WEIGHTS weight1 [weight2…]] [AGGREGATE SUM|MIN|MAX]<br>　　　　　　求key1，key2的交集，key1，key2的权值分别是weight1，weight2<br>　　　　　　聚合方法用 sum|min|max<br>　　　　　　聚合结果 保存子dest集合内</p></blockquote><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>  常用于排行榜</p><ol><li>如twitter 的public timeline可以以发表时间作为score来存储</li><li>存储成绩</li><li>还可以用zset来做带权重的队列，让重要的任务先执行</li></ol><hr><h1 id="Java连接redis"><a href="#Java连接redis" class="headerlink" title="Java连接redis"></a>Java连接redis</h1><p>导入Pom.xml依赖<br><img src="https://static-1301638910.cos.ap-guangzhou.myqcloud.com/redisPom.jpg" alt="redisPom.jpg"></p><p>测试代码</p><pre class=" language-@Test"><code class="language-@Test">public void test(){String host="127.0.0.1";int port=6379;    Jedis jedis = new Jedis(host,port);    jedis.auth("password");    jedis.close();} ```# 发布订阅    Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。命令：  > subscribe channel [channel…]：订阅一个或多个频道的信息> psubscribe pattern [pattern…]：订阅一个或多个符合规定模式的频道> publish channel message ：将信息发送到指定频道> unsubscribe [channel[channel…]]：退订频道> punsubscribe [pattern[pattern…]]：退订所有给定模式的频道### 应用场景  构建实时的消息系统，比如普通聊天、群聊等功能。1. 博客网站订阅，当作者发布就可以推送给粉丝2. 微信公众号模式# 事务## 事务操作命令> Multi> 语法：multi> 标记一个事务的开始，事务内的多条命令会按照先后顺序被放进一个队列当中>> Exec> 语法：exec> 执行所有事务内的命令，事务被打断返回nil>> discard> 语法：discard> 取消事务，放弃执行事务块内的所有命令>> Watch> 语法：watch key[key...]> 监视一个或多个key，如果在事务执行之前这个key被其他命令所改动，那么事务将被打断>> Unwatch> 语法：unwatch> 取消watch命令对所有key的监视。如果在执行watch后 ，exec命令或discard命令先被执行了的话，那么就不需要再执行unwatch了# 持久化## RDB方式    RDB方式持久化，需在redis.conf文件中配置即可，默认配置是启用的  1.配置执行RDB生成快照文件的时间策略对redis进行设置，让它在”n秒内数据集至少有M个key改动”这一条件被满足时，自动保存一次数据集　　配置格式：  save  <seconds>  <changes>　　　　Save 900 1        //每900秒（15分钟）至少1个key发生变化，产生快照　　　　Save 300 10        //每300秒（5分钟）至少10个key发生变化，产生快照　　Save 60 10000        //每60秒（1分钟）至少10000个key发生变化，产生快照  2.Dbfilename:设置RDB的文件名，默认文件名为dump.rdb  3.Dir:指定RDB文件的存储位置，默认是./当前目录> 优点：保存速度、还原速度极快,适用于灾难备份> 缺点：小内存的机器不适合使用。RDB机制符合要求就会照快照。## AOF方式    Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录操作，读操作不记录），到redis重启时，它通过执行AOF文件中所有的命令来恢复数据实现方式:AOF方式实现持久化，仅需要再redis.conf文件中配置即可    　　1.appendonly：默认是no，改成页数即可开启aof持久化    　　2.Appendfilename：指定AOF文件名，默认文件名为appendonly.aof    　　3.Dir：指定RDB和AOF文件存放的目录，默认是./    　　4.Appendfsync：配置项aof文件写命令数据的策略：　　　　No：不主动惊喜同步操作，而是完全交由操作系统来做（即每30秒一次），比较快但不是很安全　　　　Always：每次执行写入都会执行同步，慢一些但是比较安全。　　　　Everysec：每秒执行一次同步操作，比较平衡，介于速度和安全之间。这是默认项。　　5.auto-aof-rewrite-min-size:允许重写的最小AOF文件大小，默认是64M。当AOF文件大与64M时，开始整理AOF文件，去掉无用的操作命令。缩小AOF文件。> 缺点：有些命令是多余的# 主从复制主从复制的作用主要包括：    数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。    故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。    负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。    高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。## 容灾处理当master服务出现故障，需手动将slave中的一个提升为master，剩下的slave挂至新的master上（冷处理：机械挂掉了，再处理）命令：</code></pre><p>Slaveof no noe 将一台slave服务器提升为master（提升某slave为master）<br>Slaveof 127.0.0.1. 6381 （将slave挂至新的master上） </p><p>```</p><h1 id="高可用sentinel哨兵"><a href="#高可用sentinel哨兵" class="headerlink" title="高可用sentinel哨兵"></a>高可用sentinel哨兵</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> java </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
